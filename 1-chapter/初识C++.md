1.1、初识c++
    1）、混合型语言：以.cpp 为文件扩展名，必须有一个且只能有一个名为 mian()(并不是关键字)的主函数，真正的面向对象语言没有主函数，c++保留了这个面向过的主函数，所以称之为混合型语言。
    2）、c++新标准：所谓新标准就是要将新标准类库中的头文件和一般头文件（使用.h为扩展名）区分开

2、流的输入和输出：`<<`输出信息到屏幕,`>>`接受键盘输入

```c++
#include <iostream>
using namespace std;
int a;
cin>>a;
cout<<'hw';//打印’hw‘
```

3、命名空间
C 一直使用`.h`扩展名表示头文件，新的 c++标准引入新的标准库的头文件载入方式
```c++
using namespace std;
```
- 命名空间就是把程序库的名称封装起来的方法，提高程序的可读性和可靠性。
- c++标准中的标准类库的变量与函数都属于命名空间std
    1）、作用：曝光命名空间中要使用的函数名称，比如要使用`cin`和`cout`不仅要引入头文件`iostream`,还要引用命名空间


4、对象定义及初始化
    1）、定义：定义对象包括为他命名并赋值并赋予数据类型
下例使用构造函数语法进行初始化赋值
```c++
int z(50);//等于int z=50；
```

5、函数原型及返回值
    1）、函数类型：c++函数中有库函数（标准函数）和自定义函数两种类型。
    2）、函数返回类型：函数都需要类型说明。`int main()`说明main函数是个整数类型。返回值是由`return`后面的表达式决定的，表达式必须和声明函数类型一致。
    3）、变量、函数使用原则：必须先声明，后使用
    4）、返回值：如果程序没有返回值可以用`return 0`来表示main函数的结束，如果确实不需要返回值，可以直接用`void`表示，这样函数体内就不需要`return 0`的语句了,因为会报错，但可是使用`return`，虽然不会报错但实属多此一举。

6、const修饰符和预处理程序
    1）、const修饰符：C语言一般用宏定义`#define`定义常量，c++中用`const`代替宏定义，用关键字`const`修饰的标识符是一类特殊的常量---符号常量，__切记：不可更改const定义的变量,以提高程序安全性__.
    2）、宏定义：c++中仍可使用宏定义，无参数的宏作为常量，而带参数的宏可以提供比函数调用有更高的效率,
    但是预处理只是进行简单的文本代替而不是类型检查，
```c++
#define BUFSIZE 100; //
```
· 这里的BUFSIZE只是个名字，不占储存空间并被存放在一个头文件中，再编译期间将用100来代替所有的BUFSIZE。存在类型问题， 比如BUFSIZE究竟是整数类型还输浮点类型呢？用以下方式可以解决：
```c++
const int BUFSIZE=100; //
```
    2）、预处理程序：c++预处理程序不是c++编译程序的一部分，对这几种特殊语句的句分析处理是在编译程序之前进行的，预处理语句有三种：
    - 宏定义（`#define SIZE 10`）
    - 文件包括（`#include “filename”（用户自定义，在当前目录或者指定目录）/#include <filename>（首先在系统设定目录寻找）`）
    - 条件编译

7、程序运行结果


1.2、c++面向过程的特点

1、函数重载
    1）、c++允许在同一个作用域中对同一个函数指定多个定义

```c++
#include <iostream>
using namespace std;
 
class printData
{
   public:
      void print(int i) {
        cout << "整数为: " << i << endl;
      }
 
      void print(double  f) {
        cout << "浮点数为: " << f << endl;
      }

      void print(char c[]) {
        cout << "字符串为: " << c << endl;
      }

      void print(int i,double f) {
        cout << "i和f想加为: " << i+f << endl;
      }
};

int main(void)
{
   printData pd;
 
   // 输出整数
   pd.print(5);
   // 输出浮点数
   pd.print(500.263);
   // 输出字符串
   char c[] = "Hello C++";
   pd.print(c);
   // 输出整形和浮点数想加的结果
   pd.print(1,1.11);
 
   return 0;
}
```

2、新的基本数据类型
    1）、新增数据类型：c++比c多个了`bool`型；c++只限定`int`和`short`至少有16位，`long`至少有32位，short不得长于int，int不得长于long，Visual c++规定int使用4个字节。
    2）、&：用来取对象储存的首地址
    3）、4种整数常量类型：
```c++
85         // 十进制
0213       // 八进制 -前缀零
0x4b       // 十六进制 -前缀0x
30         // 整数 
30u        // 无符号整数 
30l  -24531      // 长整数 -后缀L或者l
30ul       // 无符号长整数
```

    4)、可后缀表示的浮点常量的类型：F或f表示是`float`类型；L或1表示是`long`或`double`类型；若没有后缀，则是double类型，例如：
    - 当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。
    - 当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。例如：3.45E6，这指的是3.45与1000000相乘的结果；E6指的是10的6次方，即1后面6个0.一次，3.45E6表示的是3450000，6被称为指数，3.45被称为尾数
```c++
3.14159       // 合法的 double类型
314159E-5L    // 合法的 长浮点数 指数为负数意味着除以10的乘方，而不是乘以10的乘方。因此，314159E-5L表示314159/10^5
510E          // 非法的：不完整的指数
210f          // 非法的：没有小数或指数
.e55          // 非法的：缺少整数或分数
```
    5)、字符常量：字符常量是括在单引号中。如果常量以 L（仅当大写时）开头，则表示它是一个宽字符常量（例如 L'x'），此时它必须存储在 wchar_t 类型的变量中。否则，它就是一个窄字符常量（例如 'x'），此时它可以存储在 char 类型的简单变量中。例如：
    - 一个转义序列（例如 '\t'），或一个通用的字符（例如 '\u02C0'）。
    - "\101"表示ASCII码值位101的A字符

3、动态分配内存
    1）、在使用指针时，如果不使用对象地址初始化指针，可以自己给它分配地址，对于只储存一个基本类数据的指针，申请方式如下：
        `new typename[size]`,`size`代表申请多少个该类型数据的对象。
    2）、释放申请的空间：`delete 指针名`

```c++
#include <iostream>
using namespace std;//c++标准中的标准类库的变量与函数都属于命名空间std

int main() {
    int * a;                     //声明int类型指针
    a=new int(3);                //分配三个int类型的储存空间给指针a
    for(int i=0;i<3;i++){        //定义对象i初始值为0
        cin>>*(a+i);             //把输入的数据存入指定地址
    }
    for(int i=0;i<3;i++){
        cout <<"输出："<< *(a+i)<<endl; //输出指针地址中的三个值
    }
}
```

4、引用
    1）、定义：简单来说就是为现有的对象起一个‘别名’，别名的地址其实就是原来对象的地址，选定命名时使用’引用‘运算符’&‘，再选用数据类型与之配合。声明如下：`数据类型 & 别名 =对象名`
    2)、引用VS指针：
    - 不存在空引用。引用必须连接到一块合法的内存。
    - 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。
    - 引用必须在创建时被初始化。指针可以在任何时间被初始化。
    - 指针是低级的直接操作内存地址的机制，功能强大但易产生错误，在c++中指针可由整型数强制转换得到，处理不当已造成系统的极大破坏
    而引用则是比较高级的封装了指针的特性，不直接操作内存地址，不可以由强制类型转换而得，因而具有较高安全性，也不易产生由使用指针而常常产生不易察觉的错误。在处理对象的时候，不失是一种好的选择


```c++
#include <iostream>
using namespace std;//c++标准中的标准类库的变量与函数都属于命名空间std

int main() {
    int i;
    int & r=i;//声明变量r引用变量i的引用，r和i地址相同
    i=5;
    cout <<i<<endl;
    cout <<r<<endl;
    r=10;
    cout <<i<<endl;//r改变 i也会随着变化 因为公用一个内存地址
    cout <<r<<endl;
}
```
    3）、使用：
    - 常用于函数的参数表中或者作为函数的返回值；
    - 不能直接声明对数组的引用，也不能声明对引用的引用(只可以在创建的时候初始化一次)
    - 可以声明对指针的引用（如a1是指针，则 int*& a2=a1;），__但是不能声明指针对i的引用__,即`int i=10;int *&p=&i`;
    可以声明指向指针的引用，如在上面示例中：r引用了i，可以将 int *p=&r。

    4）、关于不能直接引用数组：
    可以间接的定义数组的引用，通过`typedef`来实现，例如：`typedef int array[10]`,这里定义了一个int类型的数组类型array标识符，然后就可以用它来定义数组的引用：`array a;array &b=a;`，这样就定义了一个数组a的引用b，等于给数组a起了个别名。完整示例如下：

```c++
#include <iostream>
using namespace std;//c++标准中的标准类库的变量与函数都属于命名空间std
typedef int arr[5];    //定义一个数据类型为int的arr类型的数组
int main() {
    arr a={1,2,3,4,5};
    arr &b=a;           //创建一个arr类型的引用
    b[4]=6;             //同步变化
    for(int i=0;i<5;i++){
        cout <<b[i]<<endl;
    }
    
}
```
    4）、总结：
    所谓”引用“就是讲一个新标识符关联到一个已存在的存储区域，因此引用时并没有分配新的内存区域，它本身并不是新的数据类型；
    引用只是作为一种标识对象的手段。


5、对指针使用const限定符(可以使用const限定符强制改变访问权限)
    1）、左值和右值
    左值是指某个对象的表达式。`E1=E2`,其中左运算分量`E1`必须能被计算和修改；指针类型和引用类型的表达式可以产生左值。例如’p‘是一个指针表达式，则”*p“就是一个左值表达式，他代表由p指向的对象，并通过`*p=`改变这个对象的值。引用类型同理

    2）、指向常量的指针：
    `const int *p`,在非常量前加`const`，告诉编译器`*p`是常量，不能作为左值进行操作。限定了指针的操作，所以称之为常量的指针。
```c++
    const int a=1;
    const int *p=&a;//a不能作为左值
    int b=10;
    const int *p1=&b;//只能通过x间接改变*p1的值,
    b=*p1;//"*p1"不能作为左值，但可以改变b值，还可以当做右值使用
```

    3）、常量指针：
    把const限定符放在*号的右边，使指针本身成为一个const指针。如下：
```c++
int x=5;
int * const p=&x;//p作为常量地址，所以不能成为左值，’p=‘不成立，不能改变p的指向
*p=10;//但是这个地址的内容可以间接引用运算符”*“改变其值
```
    因为指针本身是常量。编译器要求给它初始化一个值，这个值在指针的整个生存期都不会改变。

    4）、指向常量的常量指针：
    声明指针和指向的对象都不能改动。这时必须要初始化指针。
```c++
int x=10;
const int * const p=&x;
```

6、泛型算法应用于普通数组
    1）、背景：数组不能作为整体输出，引入`STL`库可以大大简化数组操作。
    2）、泛型算法：就是提供的操作与元素的类型无关。
    
